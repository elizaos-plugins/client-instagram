{"version":3,"sources":["../src/index.ts","../src/environment.ts","../src/lib/auth.ts","../src/lib/profile.ts","../src/lib/state.ts","../src/services/interaction.ts","../src/lib/actions.ts","../src/services/post.ts"],"sourcesContent":["// src/index.ts\nimport { type Client, type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\nimport { validateInstagramConfig } from \"./environment\";\nimport { initializeClient } from \"./lib/auth\";\nimport { InstagramInteractionService } from \"./services/interaction\";\nimport { InstagramPostService } from \"./services/post\";\n\nexport const InstagramClientInterface: Client = {\n    name: 'instagram',\n    async start(runtime: IAgentRuntime) {\n        try {\n            // Validate configuration\n            const config = await validateInstagramConfig(runtime);\n            elizaLogger.log(\"Instagram client configuration validated\");\n\n            // Initialize client and get initial state\n            const state = await initializeClient(runtime, config);\n            elizaLogger.log(\"Instagram client initialized\");\n\n            // Create services\n            const postService = new InstagramPostService(runtime, state);\n            const interactionService = new InstagramInteractionService(\n                runtime,\n                state\n            );\n\n            // Start services\n            if (!config.INSTAGRAM_DRY_RUN) {\n                await postService.start();\n                elizaLogger.log(\"Instagram post service started\");\n\n                if (config.INSTAGRAM_ENABLE_ACTION_PROCESSING) {\n                    await interactionService.start();\n                    elizaLogger.log(\"Instagram interaction service started\");\n                }\n            } else {\n                elizaLogger.log(\"Instagram client running in dry-run mode\");\n            }\n\n            // Return manager instance\n            return {\n                post: postService,\n                interaction: interactionService,\n                state,\n            };\n        } catch (error) {\n            elizaLogger.error(\"Failed to start Instagram client:\", error);\n            throw error;\n        }\n    },\n    // eslint-disable-next-line\n    async stop(runtime: IAgentRuntime) {\n        elizaLogger.log(\"Stopping Instagram client services...\");\n        // Cleanup will be handled by the services themselves\n    },\n};\n\nexport default InstagramClientInterface;\n","import {\n    type IAgentRuntime,\n    parseBooleanFromText,\n} from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const DEFAULT_POST_INTERVAL_MIN = 60;\nexport const DEFAULT_POST_INTERVAL_MAX = 120;\nexport const DEFAULT_ACTION_INTERVAL = 5;\nexport const DEFAULT_MAX_ACTIONS = 1;\n\n// Define validation schemas for Instagram usernames and other fields\nconst instagramUsernameSchema = z\n    .string()\n    .min(1, \"An Instagram Username must be at least 1 character long\")\n    .max(30, \"An Instagram Username cannot exceed 30 characters\")\n    .refine((username) => {\n        // Instagram usernames can contain letters, numbers, periods, and underscores\n        return /^[A-Za-z0-9._]+$/.test(username);\n    }, \"An Instagram Username can only contain letters, numbers, periods, and underscores\");\n\n/**\n * Environment configuration schema for Instagram client\n */\nexport const instagramEnvSchema = z.object({\n    INSTAGRAM_DRY_RUN: z.boolean(),\n    INSTAGRAM_USERNAME: instagramUsernameSchema,\n    INSTAGRAM_PASSWORD: z.string().min(1, \"Instagram password is required\"),\n\n    // Instagram API credentials\n    INSTAGRAM_APP_ID: z.string().min(1, \"Instagram App ID is required\"),\n    INSTAGRAM_APP_SECRET: z.string().min(1, \"Instagram App Secret is required\"),\n\n    // Optional Business Account ID for additional features\n    INSTAGRAM_BUSINESS_ACCOUNT_ID: z.string().optional(),\n\n    // Posting configuration\n    INSTAGRAM_POST_INTERVAL_MIN: z.number().int().default(DEFAULT_POST_INTERVAL_MIN),\n    INSTAGRAM_POST_INTERVAL_MAX: z.number().int().default(DEFAULT_POST_INTERVAL_MAX),\n\n    // Action processing configuration\n    INSTAGRAM_ENABLE_ACTION_PROCESSING: z.boolean().default(false),\n    INSTAGRAM_ACTION_INTERVAL: z.number().int().default(DEFAULT_ACTION_INTERVAL),\n    INSTAGRAM_MAX_ACTIONS: z.number().int().default(DEFAULT_MAX_ACTIONS),\n});\n\nexport type InstagramConfig = z.infer<typeof instagramEnvSchema>;\n\n/**\n * Validates and constructs an InstagramConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\nexport async function validateInstagramConfig(\n    runtime: IAgentRuntime\n): Promise<InstagramConfig> {\n    try {\n        const instagramConfig = {\n            INSTAGRAM_DRY_RUN: parseBooleanFromText(\n                runtime.getSetting(\"INSTAGRAM_DRY_RUN\") ||\n                    process.env.INSTAGRAM_DRY_RUN\n            ) ?? false,\n\n            INSTAGRAM_USERNAME: runtime.getSetting(\"INSTAGRAM_USERNAME\") ||\n                process.env.INSTAGRAM_USERNAME,\n\n            INSTAGRAM_PASSWORD: runtime.getSetting(\"INSTAGRAM_PASSWORD\") ||\n                process.env.INSTAGRAM_PASSWORD,\n\n            INSTAGRAM_APP_ID: runtime.getSetting(\"INSTAGRAM_APP_ID\") ||\n                process.env.INSTAGRAM_APP_ID,\n\n            INSTAGRAM_APP_SECRET: runtime.getSetting(\"INSTAGRAM_APP_SECRET\") ||\n                process.env.INSTAGRAM_APP_SECRET,\n\n            INSTAGRAM_BUSINESS_ACCOUNT_ID: runtime.getSetting(\"INSTAGRAM_BUSINESS_ACCOUNT_ID\") ||\n                process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID,\n\n            INSTAGRAM_POST_INTERVAL_MIN: Number.parseInt(\n                runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MIN\") ||\n                    process.env.INSTAGRAM_POST_INTERVAL_MIN ||\n                    DEFAULT_POST_INTERVAL_MIN.toString(),\n                10\n            ),\n\n            INSTAGRAM_POST_INTERVAL_MAX: Number.parseInt(\n                runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MAX\") ||\n                    process.env.INSTAGRAM_POST_INTERVAL_MAX ||\n                    DEFAULT_POST_INTERVAL_MAX.toString(),\n                10\n            ),\n\n            INSTAGRAM_ENABLE_ACTION_PROCESSING: parseBooleanFromText(\n                runtime.getSetting(\"INSTAGRAM_ENABLE_ACTION_PROCESSING\") ||\n                    process.env.INSTAGRAM_ENABLE_ACTION_PROCESSING\n            ) ?? false,\n\n            INSTAGRAM_ACTION_INTERVAL: Number.parseInt(\n                runtime.getSetting(\"INSTAGRAM_ACTION_INTERVAL\") ||\n                    process.env.INSTAGRAM_ACTION_INTERVAL ||\n                    DEFAULT_ACTION_INTERVAL.toString(),\n                10\n            ),\n\n            INSTAGRAM_MAX_ACTIONS: Number.parseInt(\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\n                    process.env.MAX_ACTIONS_PROCESSING ||\n                    DEFAULT_MAX_ACTIONS.toString(),\n                10\n            ),\n        };\n\n        return instagramEnvSchema.parse(instagramConfig);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Instagram configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}","// src/lib/auth.ts\nimport { type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\nimport { IgLoginTwoFactorRequiredError } from \"instagram-private-api\";\nimport type { InstagramConfig } from \"../environment\";\nimport type { InstagramState } from \"../types\";\nimport { fetchProfile } from \"./profile\";\nimport { createInitialState, getIgClient } from \"./state\";\n\n/**\n * Authenticates with Instagram\n */\nasync function authenticate(\n    runtime: IAgentRuntime,\n    config: InstagramConfig\n): Promise<InstagramState> {\n    const ig = getIgClient();\n    const state = createInitialState();\n\n    try {\n        // Generate device ID\n        ig.state.generateDevice(config.INSTAGRAM_USERNAME);\n\n        // Attempt to load cached session\n        const cachedSession =\n            await runtime.cacheManager.get(\"instagram/session\");\n        if (cachedSession) {\n            try {\n                await ig.state.deserialize(cachedSession);\n                const profile = await fetchProfile(runtime, config);\n                return {\n                    ...state,\n                    isInitialized: true,\n                    profile,\n                };\n            } catch {\n                elizaLogger.warn(\n                    `Cached session invalid, proceeding with fresh login`\n                );\n            }\n        }\n\n        // Proceed with fresh login\n        try {\n            await ig.account.login(\n                config.INSTAGRAM_USERNAME,\n                config.INSTAGRAM_PASSWORD\n            );\n\n            // Cache the session\n            const serialized = await ig.state.serialize();\n            await runtime.cacheManager.set(\"instagram/session\", serialized);\n\n            const profile = await fetchProfile(runtime, config);\n\n            return {\n                ...state,\n                isInitialized: true,\n                profile,\n            };\n        } catch (error) {\n            if (error instanceof IgLoginTwoFactorRequiredError) {\n                // Handle 2FA if needed - would need to implement 2FA code generation\n                throw new Error(\"2FA authentication not yet implemented\");\n            }\n            throw error;\n        }\n    } catch (error) {\n        elizaLogger.error(\"Authentication failed:\", error);\n        throw error;\n    }\n}\n\n/**\n * Sets up webhooks for real-time updates if needed\n */\nasync function setupWebhooks() {\n    // Implement webhook setup\n    // This is a placeholder for future implementation\n}\n\n/**\n * Initializes the Instagram client\n */\nexport async function initializeClient(\n    runtime: IAgentRuntime,\n    config: InstagramConfig\n): Promise<InstagramState> {\n    try {\n        // Authenticate and get initial state\n        const state = await authenticate(runtime, config);\n\n        // Set up webhook handlers if needed\n        await setupWebhooks();\n\n        return state;\n    } catch (error) {\n        elizaLogger.error(\"Failed to initialize Instagram client:\", error);\n        throw error;\n    }\n}\n\n// Export other authentication related functions if needed\nexport { authenticate, setupWebhooks };\n","import { elizaLogger, type IAgentRuntime } from \"@elizaos/core\";\nimport type { InstagramConfig } from \"../environment\";\nimport type { InstagramProfile } from \"../types\";\nimport { getIgClient } from \"./state\";\n\nexport async function fetchProfile(\n    runtime: IAgentRuntime,\n    config: InstagramConfig\n  ): Promise<InstagramProfile> {\n    const ig = getIgClient();\n\n    try {\n      const userInfo = await ig.user.info(ig.state.cookieUserId);\n\n      const profile: InstagramProfile = {\n        id: userInfo.pk.toString(),\n        username: userInfo.username,\n        name: userInfo.full_name,\n        biography: userInfo.biography,\n        mediaCount: userInfo.media_count,\n        followerCount: userInfo.follower_count,\n        followingCount: userInfo.following_count\n      };\n\n      // Cache profile info\n      await runtime.cacheManager.set(\n        `instagram/profile/${config.INSTAGRAM_USERNAME}`,\n        profile\n      );\n\n      return profile;\n    } catch (error) {\n      elizaLogger.error('Error fetching profile:', error);\n      throw error;\n    }\n  }\n","import { IgApiClient } from 'instagram-private-api';\nimport type { InstagramState } from '../types';\n\n// Create a singleton for the Instagram API client\nlet igClient: IgApiClient | null = null;\n\nexport const getIgClient = () => {\n  if (!igClient) {\n    igClient = new IgApiClient();\n  }\n  return igClient;\n};\n\n// Create initial state\nexport const createInitialState = (): InstagramState => ({\n  accessToken: null,\n  longLivedToken: null,\n  profile: null,\n  isInitialized: false,\n  lastCheckedMediaId: null,\n});","import {\n    composeContext,\n    elizaLogger,\n    generateText,\n    getEmbeddingZeroVector,\n    type IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    type UUID\n} from \"@elizaos/core\";\nimport { fetchComments, likeMedia, postComment } from \"../lib/actions\";\nimport { getIgClient } from \"../lib/state\";\nimport type { InstagramState } from \"../types\";\n\n  // Templates\n  const instagramCommentTemplate = `\n  # Areas of Expertise\n  {{knowledge}}\n\n  # About {{agentName}} (@{{instagramUsername}}):\n  {{bio}}\n  {{lore}}\n  {{topics}}\n\n  {{providers}}\n\n  {{characterPostExamples}}\n\n  {{postDirections}}\n\n  # Task: Generate a response to the following Instagram comment in the voice and style of {{agentName}}.\n  Original Comment (@{{commentUsername}}): {{commentText}}\n\n  Your response should be friendly, engaging, and natural. Keep it brief (1-2 sentences).\n  Do not use hashtags in comment responses. Be conversational and authentic.`;\n\n  const shouldInteractTemplate = `\n  # About {{agentName}} (@{{instagramUsername}}):\n  {{bio}}\n  {{lore}}\n  {{topics}}\n\n  {{postDirections}}\n\n  # Task: Determine if {{agentName}} should interact with this content:\n  Interaction Type: {{interactionType}}\n  User: @{{username}}\n  Content: {{content}}\n\n  Consider:\n  1. Is this user's content relevant to {{agentName}}'s interests?\n  2. Would interaction be authentic and meaningful?\n  3. Is there potential for valuable engagement?\n\n  Respond with one of:\n  [INTERACT] - Content is highly relevant and engagement would be valuable\n  [SKIP] - Content is not relevant enough or engagement wouldn't be authentic\n\n  Choose [INTERACT] only if very confident about relevance and value.`;\n\n  export class InstagramInteractionService {\n    private runtime: IAgentRuntime;\n    private state: InstagramState;\n    private isProcessing = false;\n    private stopProcessing = false;\n\n    constructor(runtime: IAgentRuntime, state: InstagramState) {\n      this.runtime = runtime;\n      this.state = state;\n    }\n\n    async start() {\n      const handleInteractionsLoop = () => {\n        this.handleInteractions();\n        if (!this.stopProcessing) {\n          setTimeout(\n            handleInteractionsLoop,\n            Number.parseInt(this.runtime.getSetting('ACTION_INTERVAL') || '300', 10) * 1000\n          );\n        }\n      };\n\n      handleInteractionsLoop();\n    }\n\n    async stop() {\n      this.stopProcessing = true;\n    }\n\n    private async generateResponse(\n      text: string,\n      username: string,\n      action: string\n    ) {\n      const state = await this.runtime.composeState(\n        {\n          userId: this.runtime.agentId,\n          roomId: stringToUuid(`instagram-temp-${Date.now()}-${this.runtime.agentId}`),\n          agentId: this.runtime.agentId,\n          content: {\n            text,\n            action,\n          },\n        },\n        {\n          instagramUsername: this.state.profile?.username,\n          commentUsername: username,\n          commentText: text,\n        }\n      );\n\n      const context = composeContext({\n        state,\n        template: instagramCommentTemplate,\n      });\n\n      const response = await generateText({\n        runtime: this.runtime,\n        context,\n        modelClass: ModelClass.SMALL,\n      });\n\n      return this.cleanResponse(response);\n    }\n\n    private cleanResponse(response: string): string {\n      return response\n        .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\")\n        .replace(/^['\"](.*)['\"]$/g, \"$1\")\n        .replace(/\\\\\"/g, '\"')\n        .trim();\n    }\n\n    private async handleInteractions() {\n      if (this.isProcessing) {\n        elizaLogger.log(\"Already processing interactions, skipping\");\n        return;\n      }\n\n      try {\n        this.isProcessing = true;\n        elizaLogger.log(\"Checking Instagram interactions\");\n\n        const ig = getIgClient();\n        const activity = await ig.feed.news().items();\n\n        for (const item of activity) {\n          const activityId = `instagram-activity-${item.pk}`;\n          if (await this.runtime.cacheManager.get(activityId)) continue;\n\n          switch (item.type) {\n            case 2: // Comment on your post\n              await this.handleComment(item);\n              break;\n            case 3: // Like on your post\n              await this.handleLike(item);\n              break;\n            case 12: // Mention in comment\n              await this.handleMention(item);\n              break;\n          }\n\n          await this.runtime.cacheManager.set(activityId, true);\n        }\n      } catch (error) {\n        elizaLogger.error(\"Error handling Instagram interactions:\", error);\n      } finally {\n        this.isProcessing = false;\n      }\n    }\n\n    private async handleComment(item: any) {\n      try {\n        const comments = await fetchComments(item.media_id);\n        const comment = comments.find(c => c.id === item.pk.toString());\n        if (!comment) return;\n\n        const roomId = stringToUuid(`instagram-comment-${item.media_id}-${this.runtime.agentId}`);\n        const commentId = stringToUuid(`instagram-comment-${comment.id}-${this.runtime.agentId}`);\n        const userId = stringToUuid(`instagram-user-${item.user_id}-${this.runtime.agentId}`);\n\n        const cleanedResponse = await this.generateResponse(\n          comment.text,\n          comment.username,\n          \"COMMENT\"\n        );\n\n        if (!cleanedResponse) {\n          elizaLogger.error(\"Failed to generate valid comment response\");\n          return;\n        }\n\n        await this.ensureEntities(roomId, userId, comment.username);\n        await this.createInteractionMemories(\n          commentId,\n          userId,\n          roomId,\n          comment,\n          cleanedResponse,\n          item.media_id\n        );\n\n      } catch (error) {\n        elizaLogger.error(\"Error handling comment:\", error);\n      }\n    }\n\n    private async handleLike(item: any) {\n      try {\n        const state = await this.runtime.composeState(\n          {\n            userId: this.runtime.agentId,\n            roomId: stringToUuid(`instagram-like-${item.media_id}-${this.runtime.agentId}`),\n            agentId: this.runtime.agentId,\n            content: { text: \"\", action: \"DECIDE_INTERACTION\" },\n          },\n          {\n            instagramUsername: this.state.profile?.username,\n            interactionType: \"like\",\n            username: item.user?.username,\n            content: item.text || \"\",\n          }\n        );\n\n        const context = composeContext({ state, template: shouldInteractTemplate });\n        const decision = await generateText({\n          runtime: this.runtime,\n          context,\n          modelClass: ModelClass.SMALL,\n        });\n\n        if (decision.includes(\"[INTERACT]\")) {\n          const userFeed = await getIgClient().feed.user(item.user_id).items();\n          if (userFeed.length > 0) {\n            await likeMedia(userFeed[0].id);\n            elizaLogger.log(`Liked post from user: ${item.user?.username}`);\n          }\n        }\n      } catch (error) {\n        elizaLogger.error(\"Error handling like:\", error);\n      }\n    }\n\n    private async handleMention(item: any) {\n      try {\n        const roomId = stringToUuid(`instagram-mention-${item.media_id}-${this.runtime.agentId}`);\n        const mentionId = stringToUuid(`instagram-mention-${item.pk}-${this.runtime.agentId}`);\n        const userId = stringToUuid(`instagram-user-${item.user.pk}-${this.runtime.agentId}`);\n\n        const cleanedResponse = await this.generateResponse(\n          item.text,\n          item.user.username,\n          \"MENTION\"\n        );\n\n        if (!cleanedResponse) {\n          elizaLogger.error(\"Failed to generate valid mention response\");\n          return;\n        }\n\n        await this.ensureEntities(roomId, userId, item.user.username);\n        await this.createInteractionMemories(\n          mentionId,\n          userId,\n          roomId,\n          item,\n          cleanedResponse,\n          item.media_id\n        );\n\n      } catch (error) {\n        elizaLogger.error(\"Error handling mention:\", error);\n      }\n    }\n\n    private async ensureEntities(roomId: UUID, userId: UUID, username: string) {\n      await this.runtime.ensureRoomExists(roomId);\n      await this.runtime.ensureUserExists(userId, username, username, \"instagram\");\n      await this.runtime.ensureParticipantInRoom(this.runtime.agentId, roomId);\n    }\n\n    private async createInteractionMemories(\n      originalId: UUID,\n      userId: UUID,\n      roomId: UUID,\n      originalItem: any,\n      response: string,\n      mediaId: string\n    ) {\n      // Create memory of original interaction\n      await this.runtime.messageManager.createMemory({\n        id: originalId,\n        userId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: originalItem.text,\n          source: \"instagram\",\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: new Date(originalItem.timestamp || originalItem.created_at * 1000).getTime(),\n      });\n\n      // Post response\n      const postedComment = await postComment(mediaId, response);\n\n      // Create memory of our response\n      await this.runtime.messageManager.createMemory({\n        id: stringToUuid(`instagram-reply-${postedComment.id}-${this.runtime.agentId}`),\n        userId: this.runtime.agentId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: response,\n          source: \"instagram\",\n          inReplyTo: originalId\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: Date.now(),\n      });\n    }\n  }","// src/lib/actions.ts\nimport { elizaLogger } from \"@elizaos/core\";\nimport type { Comment } from \"../types\";\nimport { getIgClient } from \"./state\";\n\n/**\n * Fetches comments for a specific media post\n */\nexport async function fetchComments(\n  mediaId: string,\n  count = 20\n): Promise<Comment[]> {\n  const ig = getIgClient();\n\n  try {\n    const feed = ig.feed.mediaComments(mediaId);\n    const comments = await feed.items();\n\n    return comments.slice(0, count).map(comment => ({\n      id: comment.pk.toString(),\n      text: comment.text,\n      timestamp: new Date(comment.created_at * 1000).toISOString(),\n      username: comment.user.username,\n      replies: [] // Instagram API doesn't provide replies in the same call\n    }));\n  } catch (error) {\n    elizaLogger.error('Error fetching comments:', error);\n    throw error;\n  }\n}\n\n/**\n * Posts a comment on a media post\n */\nexport async function postComment(\n  mediaId: string,\n  text: string\n): Promise<Comment> {\n  const ig = getIgClient();\n\n  try {\n    const result = await ig.media.comment({\n      mediaId,\n      text: text.slice(0, 2200) // Instagram comment length limit\n    });\n\n    return {\n      id: result.pk.toString(),\n      text: result.text,\n      timestamp: new Date(result.created_at * 1000).toISOString(),\n      username: result.user.username,\n      replies: []\n    };\n  } catch (error) {\n    elizaLogger.error('Error posting comment:', error);\n    throw error;\n  }\n}\n\n/**\n * Likes a media post\n */\nexport async function likeMedia(mediaId: string): Promise<void> {\n  const ig = getIgClient();\n\n  try {\n    await ig.media.like({\n      mediaId,\n      moduleInfo: {\n        module_name: 'profile',\n        user_id: ig.state.cookieUserId,\n        username: ig.state.cookieUsername\n      }\n    });\n    elizaLogger.log(`Liked media: ${mediaId}`);\n  } catch (error) {\n    elizaLogger.error('Error liking media:', error);\n    throw error;\n  }\n}\n\n/**\n * Unlikes a media post\n */\nexport async function unlikeMedia(mediaId: string): Promise<void> {\n  const ig = getIgClient();\n\n  try {\n    await ig.media.unlike({\n      mediaId,\n      moduleInfo: {\n        module_name: 'profile',\n        user_id: ig.state.cookieUserId,\n        username: ig.state.cookieUsername\n      }\n    });\n    elizaLogger.log(`Unliked media: ${mediaId}`);\n  } catch (error) {\n    elizaLogger.error('Error unliking media:', error);\n    throw error;\n  }\n}\n\n/**\n * Replies to a comment\n */\nexport async function replyToComment(\n  mediaId: string,\n  commentId: string,\n  text: string\n): Promise<Comment> {\n  const ig = getIgClient();\n\n  try {\n    const result = await ig.media.comment({\n      mediaId,\n      text: text.slice(0, 2200), // Instagram comment length limit\n      replyToCommentId: commentId\n    });\n\n    return {\n      id: result.pk.toString(),\n      text: result.text,\n      timestamp: new Date(result.created_at * 1000).toISOString(),\n      username: result.user.username,\n      replies: []\n    };\n  } catch (error) {\n    elizaLogger.error('Error replying to comment:', error);\n    throw error;\n  }\n}\n\n/**\n * Deletes a comment\n */\nexport async function deleteComment(\n  mediaId: string,\n  commentId: string\n): Promise<void> {\n  const ig = getIgClient();\n\n  try {\n    await ig.media.deleteComment({\n      mediaId,\n      commentId\n    });\n    elizaLogger.log(`Deleted comment: ${commentId} from media: ${mediaId}`);\n  } catch (error) {\n    elizaLogger.error('Error deleting comment:', error);\n    throw error;\n  }\n}\n\n/**\n * Checks if current user has liked a media post\n */\nexport async function hasLikedMedia(mediaId: string): Promise<boolean> {\n  const ig = getIgClient();\n\n  try {\n    const info = await ig.media.info(mediaId);\n    return info.items[0].has_liked ?? false;\n  } catch (error) {\n    elizaLogger.error('Error checking if media is liked:', error);\n    throw error;\n  }\n}","// src/services/post.ts\nimport {\n    type IAgentRuntime,\n    ModelClass,\n    composeContext,\n    elizaLogger,\n    generateImage,\n    generateText,\n    getEmbeddingZeroVector,\n    stringToUuid,\n} from \"@elizaos/core\";\nimport { promises as fs } from \"fs\";\nimport path from \"path\";\nimport sharp from \"sharp\";\nimport { getIgClient } from \"../lib/state\";\nimport type { InstagramState } from \"../types\";\n\n// Template for generating Instagram posts\nconst instagramPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{instagramUsername}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}.\nYour response should be 1-3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only.\nAdd up to 3 relevant hashtags at the end.`;\n\ninterface PostOptions {\n    media: Array<{\n        type: \"IMAGE\" | \"VIDEO\" | \"CAROUSEL\";\n        url: string;\n    }>;\n    caption?: string;\n}\n\nexport class InstagramPostService {\n    private runtime: IAgentRuntime;\n    private state: InstagramState;\n    private isProcessing = false;\n    private lastPostTime = 0;\n    private stopProcessing = false;\n\n    constructor(runtime: IAgentRuntime, state: InstagramState) {\n        this.runtime = runtime;\n        this.state = state;\n    }\n\n    async start() {\n        const generatePostLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"instagram/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes = Number.parseInt(\n                this.runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MIN\") || this.runtime.getSetting(\"POST_INTERVAL_MIN\") || \"90\",\n                10\n            );\n            const maxMinutes = Number.parseInt(\n                this.runtime.getSetting(\"INSTAGRAM_POST_INTERVAL_MAX\") || this.runtime.getSetting(\"POST_INTERVAL_MAX\") || \"180\",\n                10\n            );\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewPost();\n            }\n\n            if (!this.stopProcessing) {\n                setTimeout(generatePostLoop, delay);\n            }\n\n            elizaLogger.log(\n                `Next Instagram post scheduled in ${randomMinutes} minutes`\n            );\n        };\n\n        // Start the loop\n        generatePostLoop();\n    }\n\n    async stop() {\n        this.stopProcessing = true;\n    }\n\n    private async generateNewPost() {\n        try {\n            elizaLogger.log(\"Generating new Instagram post\");\n\n            const roomId = stringToUuid(\n                \"instagram_generate_room-\" + this.state.profile?.username\n            );\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.state.profile?.username || \"\",\n                this.runtime.character.name,\n                \"instagram\"\n            );\n\n            const topics = this.runtime.character.topics.join(\", \");\n\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics || \"\",\n                        action: \"POST\",\n                    },\n                },\n                {\n                    instagramUsername: this.state.profile?.username,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                // TODO: Add back in when we have a template for Instagram on character\n                //template: this.runtime.character.templates?.instagramPostTemplate || instagramPostTemplate,\n                template: instagramPostTemplate,\n            });\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const content = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // Clean the generated content\n            let cleanedContent = \"\";\n\n            // Try parsing as JSON first\n            try {\n                const parsedResponse = JSON.parse(content);\n                if (parsedResponse.text) {\n                    cleanedContent = parsedResponse.text;\n                } else if (typeof parsedResponse === \"string\") {\n                    cleanedContent = parsedResponse;\n                }\n            } catch {\n                // If not JSON, clean the raw content\n                cleanedContent = content\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\n                    .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines\n                    .trim();\n            }\n\n            if (!cleanedContent) {\n                elizaLogger.error(\n                    \"Failed to extract valid content from response:\",\n                    {\n                        rawResponse: content,\n                        attempted: \"JSON parsing\",\n                    }\n                );\n                return;\n            }\n\n            // For Instagram, we need to generate or get an image\n            const mediaUrl = await this.getOrGenerateImage(cleanedContent);\n\n            await this.createPost({\n                media: [\n                    {\n                        type: \"IMAGE\",\n                        url: mediaUrl,\n                    },\n                ],\n                caption: cleanedContent,\n            });\n\n            // Create memory of the post\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(`instagram-post-${Date.now()}`),\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: cleanedContent,\n                    source: \"instagram\",\n                },\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: Date.now(),\n            });\n        } catch (error) {\n            elizaLogger.error(\"Error generating Instagram post:\", {\n                error: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : undefined,\n                phase: \"generateNewPost\",\n            });\n        }\n    }\n\n    // Placeholder - implement actual image generation/selection\n    private async getOrGenerateImage(content: string): Promise<string> {\n        try {\n            elizaLogger.log(\"Generating image for Instagram post\");\n\n            let imageSettings = this.runtime.character.settings.imageSettings || {};\n\n            const result = await generateImage(\n                {\n                    prompt: content,\n                    width: imageSettings?.width || 1024,\n                    height: imageSettings?.height || 1024,\n                    count: imageSettings?.count || 1,\nnegativePrompt: imageSettings?.negativePrompt || null,\n                    numIterations: imageSettings?.numIterations || 50,\n                    guidanceScale: imageSettings?.guidanceScale || 7.5,\nseed: imageSettings?.seed || null,\n                    modelId: imageSettings?.modelId || null,\n                    jobId: imageSettings?.jobId || null,\n                    stylePreset: imageSettings?.stylePreset || \"\",\n                    hideWatermark: imageSettings?.hideWatermark ?? true,\n                    safeMode: imageSettings?.safeMode ?? true,\n                    cfgScale: imageSettings?.cfgScale || null,\n                },\n                this.runtime\n            );\n\n            if (!result.success || !result.data || result.data.length === 0) {\n                throw new Error(\n                    \"Failed to generate image: \" +\n                        (result.error || \"No image data returned\")\n                );\n            }\n\n            // Save the base64 image to a temporary file\n            const imageData = result.data[0].replace(\n                /^data:image\\/\\w+;base64,/,\n                \"\"\n            );\n            const tempDir = path.resolve(process.cwd(), \"temp\");\n            await fs.mkdir(tempDir, { recursive: true });\n            const tempFile = path.join(\n                tempDir,\n                `instagram-post-${Date.now()}.png`\n            );\n            await fs.writeFile(tempFile, Buffer.from(imageData, \"base64\"));\n\n            return tempFile;\n        } catch {\n            // If not JSON, clean the raw content\n            cleanedContent = content\n              .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\n              .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\n              .replace(/\\\\\"/g, '\"') // Unescape quotes\n              .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines\n              .trim();\n        }\n\n      if (!cleanedContent) {\n        elizaLogger.error(\"Failed to extract valid content from response:\", {\n          rawResponse: content,\n          attempted: \"JSON parsing\",\n        });\n        return;\n      }\n\n      // For Instagram, we need to generate or get an image\n      const mediaUrl = await this.getOrGenerateImage(cleanedContent);\n\n      await this.createPost({\n        media: [{\n          type: 'IMAGE',\n          url: mediaUrl\n        }],\n        caption: cleanedContent\n      });\n\n      // Create memory of the post\n      await this.runtime.messageManager.createMemory({\n        id: stringToUuid(`instagram-post-${Date.now()}`),\n        userId: this.runtime.agentId,\n        agentId: this.runtime.agentId,\n        content: {\n          text: cleanedContent,\n          source: \"instagram\",\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: Date.now(),\n      });\n\n    } catch (error) {\n      elizaLogger.error(\"Error generating Instagram post:\", {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n        phase: 'generateNewPost'\n      });\n    }\n\n    async createPost(options: PostOptions) {\n        const ig = getIgClient();\n\n        try {\n            elizaLogger.log(\"Creating Instagram post\", {\n                mediaCount: options.media.length,\n                hasCaption: !!options.caption,\n            });\n\n            // Process media\n            const processedMedia = await Promise.all(\n                options.media.map(async (media) => {\n                    const buffer = await this.processMedia(media);\n                    return {\n                        ...media,\n                        buffer,\n                    };\n                })\n            );\n\n            // Handle different post types\n            if (processedMedia.length > 1) {\n                // Create carousel post\n                await ig.publish.album({\n                    items: processedMedia.map((media) => ({\n                        file: media.buffer,\n                        caption: options.caption,\n                    })),\n                });\n            } else {\n                // Single image/video post\n                const media = processedMedia[0];\n                if (media.type === \"VIDEO\") {\n                    await ig.publish.video({\n                        video: media.buffer,\n                        caption: options.caption,\n                        coverImage: media.buffer,\n                    });\n                } else {\n                    await ig.publish.photo({\n                        file: media.buffer,\n                        caption: options.caption,\n                    });\n                }\n            }\n\n            // Update last post time\n            this.lastPostTime = Date.now();\n            await this.runtime.cacheManager.set(\"instagram/lastPost\", {\n                timestamp: this.lastPostTime,\n            });\n\n            elizaLogger.log(\"Instagram post created successfully\");\n        } catch (error) {\n            elizaLogger.error(\"Error creating Instagram post:\", {\n                error: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : undefined,\n                phase: \"createPost\",\n                mediaCount: options.media.length,\n                hasCaption: !!options.caption,\n            });\n            throw error;\n        }\n    }\n\n    private async processMedia(media: {\n        type: string;\n        url: string;\n    }): Promise<Buffer> {\n        try {\n            elizaLogger.log(\"Processing media\", {\n                type: media.type,\n                url: media.url,\n            });\n\n            // Read file directly from filesystem instead of using fetch\n            const buffer = await fs.readFile(media.url);\n\n            if (media.type === \"IMAGE\") {\n                // Process image with sharp\n                return await sharp(buffer)\n                    .resize(1080, 1080, {\n                        fit: \"inside\",\n                        withoutEnlargement: true,\n                    })\n                    .jpeg({\n                        quality: 85,\n                        progressive: true,\n                    })\n                    .toBuffer();\n            }\n\n            // For other types, return original buffer\n            return buffer;\n        } catch (error) {\n            elizaLogger.error(\"Error processing media:\", {\n                error: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : undefined,\n                phase: \"processMedia\",\n                mediaType: media.type,\n                url: media.url,\n            });\n            throw error;\n        }\n    }\n}\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","roomId","ModelClass","composeContext","elizaLogger","generateText","getEmbeddingZeroVector","stringToUuid","elizaLogger","roomId","stringToUuid","composeContext","generateText","ModelClass","cleanedContent","getEmbeddingZeroVector","elizaLogger"]}